diff -rup binutils.orig/bfd/aoutx.h binutils-2.27/bfd/aoutx.h
--- binutils.orig/bfd/aoutx.h	2017-03-24 13:50:55.358188013 +0000
+++ binutils-2.27/bfd/aoutx.h	2017-03-24 14:26:38.438542134 +0000
@@ -2807,9 +2807,17 @@ NAME (aout, find_nearest_line) (bfd *abf
 	*filename_ptr = main_file_name;
       else
 	{
-	  sprintf (buf, "%s%s", directory_name, main_file_name);
-	  *filename_ptr = buf;
-	  buf += filelen + 1;
+	  if (buf == NULL)
+	    /* PR binutils/20891: In a corrupt input file both
+	       main_file_name and directory_name can be empty...  */
+	    * filename_ptr = NULL;
+	  else
+	    {
+	      snprintf (buf, filelen + 1, "%s%s", directory_name,
+			main_file_name);
+	      *filename_ptr = buf;
+	      buf += filelen + 1;
+	    }
 	}
     }
 
@@ -2818,6 +2826,13 @@ NAME (aout, find_nearest_line) (bfd *abf
       const char *function = func->name;
       char *colon;
 
+      if (buf == NULL)
+	{
+	  /* PR binutils/20892: In a corrupt input file func can be empty.  */
+	  * functionname_ptr = NULL;
+	  return TRUE;
+	}
+
       /* The caller expects a symbol name.  We actually have a
 	 function name, without the leading underscore.  Put the
 	 underscore back in, so that the caller gets a symbol name.  */
diff -rup binutils.orig/bfd/compress.c binutils-2.27/bfd/compress.c
--- binutils.orig/bfd/compress.c	2017-03-24 13:50:55.362187961 +0000
+++ binutils-2.27/bfd/compress.c	2017-03-24 14:17:49.075366778 +0000
@@ -292,7 +292,7 @@ bfd_get_full_section_contents (bfd *abfd
 	   SHF_COMPRESSED section.  */
 	compression_header_size = 12;
       if (!decompress_contents (compressed_buffer + compression_header_size,
-				sec->compressed_size, p, sz))
+				sec->compressed_size - compression_header_size, p, sz))
 	{
 	  bfd_set_error (bfd_error_bad_value);
 	  if (p != *ptr)
diff -rup binutils.orig/bfd/peicode.h binutils-2.27/bfd/peicode.h
--- binutils.orig/bfd/peicode.h	2017-03-24 13:50:55.374187806 +0000
+++ binutils-2.27/bfd/peicode.h	2017-03-24 14:22:36.326663483 +0000
@@ -1264,7 +1264,8 @@ pe_ILF_object_p (bfd * abfd)
     }
 
   symbol_name = (char *) ptr;
-  source_dll  = symbol_name + strlen (symbol_name) + 1;
+  /* See PR 20905 for an example of where the strnlen is necessary.  */
+  source_dll  = symbol_name + strnlen (symbol_name, size - 1) + 1;
 
   /* Verify that the strings are null terminated.  */
   if (ptr[size - 1] != 0
diff -rup binutils.orig/binutils/dwarf.c binutils-2.27/binutils/dwarf.c
--- binutils.orig/binutils/dwarf.c	2017-03-24 13:50:55.381187716 +0000
+++ binutils-2.27/binutils/dwarf.c	2017-03-24 13:58:05.061648769 +0000
@@ -76,7 +76,6 @@ int dwarf_check = 0;
    as a zero-terminated list of section indexes comprising one set of debug
    sections from a .dwo file.  */
 
-static int cu_tu_indexes_read = 0;
 static unsigned int *shndx_pool = NULL;
 static unsigned int shndx_pool_size = 0;
 static unsigned int shndx_pool_used = 0;
@@ -99,7 +98,7 @@ static int tu_count = 0;
 static struct cu_tu_set *cu_sets = NULL;
 static struct cu_tu_set *tu_sets = NULL;
 
-static void load_cu_tu_indexes (void *file);
+static bfd_boolean load_cu_tu_indexes (void *);
 
 /* Values for do_debug_lines.  */
 #define FLAG_DEBUG_LINES_RAW	 1
@@ -2713,7 +2712,7 @@ load_debug_info (void * file)
     return num_debug_info_entries;
 
   /* If this is a DWARF package file, load the CU and TU indexes.  */
-  load_cu_tu_indexes (file);
+  (void) load_cu_tu_indexes (file);
 
   if (load_debug_section (info, file)
       && process_debug_info (&debug_displays [info].section, file, abbrev, 1, 0))
@@ -7302,21 +7301,27 @@ process_cu_tu_index (struct dwarf_sectio
    section sets that we can use to associate a .debug_info.dwo section
    with its associated .debug_abbrev.dwo section in a .dwp file.  */
 
-static void
+static bfd_boolean
 load_cu_tu_indexes (void *file)
 {
+  static int cu_tu_indexes_read = -1; /* Tri-state variable.  */
+
   /* If we have already loaded (or tried to load) the CU and TU indexes
      then do not bother to repeat the task.  */
-  if (cu_tu_indexes_read)
-    return;
-
-  if (load_debug_section (dwp_cu_index, file))
-    process_cu_tu_index (&debug_displays [dwp_cu_index].section, 0);
+  if (cu_tu_indexes_read == -1)
+    {
+      cu_tu_indexes_read = TRUE;
+  
+      if (load_debug_section (dwp_cu_index, file))
+       if (! process_cu_tu_index (&debug_displays [dwp_cu_index].section, 0))
+         cu_tu_indexes_read = FALSE;
 
-  if (load_debug_section (dwp_tu_index, file))
-    process_cu_tu_index (&debug_displays [dwp_tu_index].section, 0);
+      if (load_debug_section (dwp_tu_index, file))
+       if (! process_cu_tu_index (&debug_displays [dwp_tu_index].section, 0))
+         cu_tu_indexes_read = FALSE;
+    }
 
-  cu_tu_indexes_read = 1;
+  return (bfd_boolean) cu_tu_indexes_read;
 }
 
 /* Find the set of sections that includes section SHNDX.  */
@@ -7326,7 +7331,8 @@ find_cu_tu_set (void *file, unsigned int
 {
   unsigned int i;
 
-  load_cu_tu_indexes (file);
+  if (! load_cu_tu_indexes (file))
+    return NULL;
 
   /* Find SHNDX in the shndx pool.  */
   for (i = 0; i < shndx_pool_used; i++)
diff -rup binutils.orig/binutils/readelf.c binutils-2.27/binutils/readelf.c
--- binutils.orig/binutils/readelf.c	2017-03-24 13:50:55.390187599 +0000
+++ binutils-2.27/binutils/readelf.c	2017-03-24 14:16:39.008271196 +0000
@@ -674,8 +674,14 @@ find_section_in_set (const char * name,
   if (set != NULL)
     {
       while ((i = *set++) > 0)
-	if (streq (SECTION_NAME (section_headers + i), name))
-	  return section_headers + i;
+       {
+         /* See PR 21156 for a reproducer.  */
+         if (i >= elf_header.e_shnum)
+           continue; /* FIXME: Should we issue an error message ?  */
+
+         if (streq (SECTION_NAME (section_headers + i), name))
+           return section_headers + i;
+       }
     }
 
   return find_section (name);
@@ -11342,16 +11348,32 @@ process_syminfo (FILE * file ATTRIBUTE_U
   return 1;
 }
 
+#define IN_RANGE(START,END,ADDR,OFF)		\
+  (((ADDR) >= (START)) && ((ADDR) + (OFF) < (END)))
+
 /* Check to see if the given reloc needs to be handled in a target specific
    manner.  If so then process the reloc and return TRUE otherwise return
-   FALSE.  */
+   FALSE.
+
+   If called with reloc == NULL, then this is a signal that reloc processing
+   for the current section has finished, and any saved state should be
+   discarded.  */
 
 static bfd_boolean
 target_specific_reloc_handling (Elf_Internal_Rela * reloc,
 				unsigned char *     start,
-				Elf_Internal_Sym *  symtab)
+				unsigned char *     end,
+				Elf_Internal_Sym *  symtab,
+				unsigned long       num_syms)
 {
-  unsigned int reloc_type = get_reloc_type (reloc->r_info);
+  unsigned int reloc_type = 0;
+  unsigned long sym_index = 0;
+
+  if (reloc)
+    {
+      reloc_type = get_reloc_type (reloc->r_info);
+      sym_index = get_reloc_symindex (reloc->r_info);
+    }
 
   switch (elf_header.e_machine)
     {
@@ -11360,13 +11382,25 @@ target_specific_reloc_handling (Elf_Inte
       {
 	static Elf_Internal_Sym * saved_sym = NULL;
 
+	if (reloc == NULL)
+	  {
+	    saved_sym = NULL;
+	    return TRUE;
+	  }
+
 	switch (reloc_type)
 	  {
 	  case 10: /* R_MSP430_SYM_DIFF */
 	    if (uses_msp430x_relocs ())
 	      break;
+	    /* Fall through.  */
 	  case 21: /* R_MSP430X_SYM_DIFF */
-	    saved_sym = symtab + get_reloc_symindex (reloc->r_info);
+	    /* PR 21139.  */
+	    if (sym_index >= num_syms)
+	      error (_("MSP430 SYM_DIFF reloc contains invalid symbol index %lu\n"),
+		     sym_index);
+	    else
+	      saved_sym = symtab + sym_index;
 	    return TRUE;
 
 	  case 1: /* R_MSP430_32 or R_MSP430_ABS32 */
@@ -11388,13 +11422,24 @@ target_specific_reloc_handling (Elf_Inte
 	  handle_sym_diff:
 	    if (saved_sym != NULL)
 	      {
+		int reloc_size = reloc_type == 1 ? 4 : 2;
 		bfd_vma value;
 
-		value = reloc->r_addend
-		  + (symtab[get_reloc_symindex (reloc->r_info)].st_value
-		     - saved_sym->st_value);
+		if (sym_index >= num_syms)
+		  error (_("MSP430 reloc contains invalid symbol index %lu\n"),
+			 sym_index);
+		else
+		  {
+		    value = reloc->r_addend + (symtab[sym_index].st_value
+					       - saved_sym->st_value);
 
-		byte_put (start + reloc->r_offset, value, reloc_type == 1 ? 4 : 2);
+		    if (IN_RANGE (start, end, start + reloc->r_offset, reloc_size))
+		      byte_put (start + reloc->r_offset, value, reloc_size);
+		    else
+		      /* PR 21137 */
+		      error (_("MSP430 sym diff reloc contains invalid offset: 0x%lx\n"),
+			     (long) reloc->r_offset);
+		  }
 
 		saved_sym = NULL;
 		return TRUE;
@@ -11414,24 +11459,46 @@ target_specific_reloc_handling (Elf_Inte
       {
 	static Elf_Internal_Sym * saved_sym = NULL;
 
+	if (reloc == NULL)
+	  {
+	    saved_sym = NULL;
+	    return TRUE;
+	  }
+
 	switch (reloc_type)
 	  {
 	  case 34: /* R_MN10300_ALIGN */
 	    return TRUE;
+
 	  case 33: /* R_MN10300_SYM_DIFF */
-	    saved_sym = symtab + get_reloc_symindex (reloc->r_info);
+	    if (sym_index >= num_syms)
+	      error (_("MN10300_SYM_DIFF reloc contains invalid symbol index %lu\n"),
+		     sym_index);
+	    else
+	      saved_sym = symtab + sym_index;
 	    return TRUE;
+
 	  case 1: /* R_MN10300_32 */
 	  case 2: /* R_MN10300_16 */
 	    if (saved_sym != NULL)
 	      {
+		int reloc_size = reloc_type == 1 ? 4 : 2;
 		bfd_vma value;
 
-		value = reloc->r_addend
-		  + (symtab[get_reloc_symindex (reloc->r_info)].st_value
-		     - saved_sym->st_value);
+		if (sym_index >= num_syms)
+		  error (_("MN10300 reloc contains invalid symbol index %lu\n"),
+			 sym_index);
+		else
+		  {
+		    value = reloc->r_addend + (symtab[sym_index].st_value
+					       - saved_sym->st_value);
 
-		byte_put (start + reloc->r_offset, value, reloc_type == 1 ? 4 : 2);
+		    if (IN_RANGE (start, end, start + reloc->r_offset, reloc_size))
+		      byte_put (start + reloc->r_offset, value, reloc_size);
+		    else
+		      error (_("MN10300 sym diff reloc contains invalid offset: 0x%lx\n"),
+			     (long) reloc->r_offset);
+		  }
 
 		saved_sym = NULL;
 		return TRUE;
@@ -11451,12 +11518,24 @@ target_specific_reloc_handling (Elf_Inte
 	static bfd_vma saved_sym2 = 0;
 	static bfd_vma value;
 
+	if (reloc == NULL)
+	  {
+	    saved_sym1 = saved_sym2 = 0;
+	    return TRUE;
+	  }
+
 	switch (reloc_type)
 	  {
 	  case 0x80: /* R_RL78_SYM.  */
 	    saved_sym1 = saved_sym2;
-	    saved_sym2 = symtab[get_reloc_symindex (reloc->r_info)].st_value;
-	    saved_sym2 += reloc->r_addend;
+	    if (sym_index >= num_syms)
+	      error (_("RL78_SYM reloc contains invalid symbol index %lu\n"),
+		     sym_index);
+	    else
+	      {
+		saved_sym2 = symtab[sym_index].st_value;
+		saved_sym2 += reloc->r_addend;
+	      }
 	    return TRUE;
 
 	  case 0x83: /* R_RL78_OPsub.  */
@@ -11466,12 +11545,20 @@ target_specific_reloc_handling (Elf_Inte
 	    break;
 
 	  case 0x41: /* R_RL78_ABS32.  */
-	    byte_put (start + reloc->r_offset, value, 4);
+	    if (IN_RANGE (start, end, start + reloc->r_offset, 4))
+	      byte_put (start + reloc->r_offset, value, 4);
+	    else
+	      error (_("RL78 sym diff reloc contains invalid offset: 0x%lx\n"),
+		     (long) reloc->r_offset);
 	    value = 0;
 	    return TRUE;
 
 	  case 0x43: /* R_RL78_ABS16.  */
-	    byte_put (start + reloc->r_offset, value, 2);
+	    if (IN_RANGE (start, end, start + reloc->r_offset, 2))
+	      byte_put (start + reloc->r_offset, value, 2);
+	    else
+	      error (_("RL78 sym diff reloc contains invalid offset: 0x%lx\n"),
+		     (long) reloc->r_offset);
 	    value = 0;
 	    return TRUE;
 
@@ -12078,7 +12165,7 @@ apply_relocations (void *
 
 	  reloc_type = get_reloc_type (rp->r_info);
 
-	  if (target_specific_reloc_handling (rp, start, symtab))
+	  if (target_specific_reloc_handling (rp, start, end, symtab, num_syms))
 	    continue;
 	  else if (is_none_reloc (reloc_type))
 	    continue;
@@ -12174,6 +12261,9 @@ apply_relocations (void *
 	}
 
       free (symtab);
+      /* Let the target specific reloc processing code know that
+        we have finished with these relocs.  */
+      target_specific_reloc_handling (NULL, NULL, NULL, NULL, 0);
 
       if (relocs_return)
 	{
@@ -12471,10 +12561,18 @@ dump_section_as_bytes (Elf_Internal_Shdr
 	  new_size -= 12;
 	}
 
-      if (uncompressed_size
-	  && uncompress_section_contents (& start, uncompressed_size,
-					  & new_size))
-	section_size = new_size;
+      if (uncompressed_size)
+	{
+	  if (uncompress_section_contents (& start, uncompressed_size,
+					   & new_size))
+	    section_size = new_size;
+	  else
+	    {
+	      error (_("Unable to decompress section %s\n"),
+		     printable_section_name (section));
+	      return;
+	    }
+	}
     }
 
   if (relocate)
diff -rup binutils.orig/binutils/stabs.c binutils-2.27/binutils/stabs.c
--- binutils.orig/binutils/stabs.c	2017-03-24 13:50:55.386187651 +0000
+++ binutils-2.27/binutils/stabs.c	2017-03-24 14:14:20.823055085 +0000
@@ -232,6 +232,10 @@ parse_number (const char **pp, bfd_boole
 
   orig = *pp;
 
+  /* Stop early if we are passed an empty string.  */
+  if (*orig == 0)
+    return (bfd_vma) 0;
+
   errno = 0;
   ul = strtoul (*pp, (char **) pp, 0);
   if (ul + 1 != 0 || errno == 0)
@@ -1975,9 +1979,17 @@ parse_stab_enum_type (void *dhandle, con
       bfd_signed_vma val;
 
       p = *pp;
-      while (*p != ':')
+      while (*p != ':' && *p != 0)
 	++p;
 
+      if (*p == 0)
+       {
+         bad_stab (orig);
+         free (names);
+         free (values);
+         return DEBUG_TYPE_NULL;
+       }
+
       name = savestring (*pp, p - *pp);
 
       *pp = p + 1;
diff -rup binutils.orig/gas/app.c binutils-2.27/gas/app.c
--- binutils.orig/gas/app.c	2017-03-24 13:50:55.395187534 +0000
+++ binutils-2.27/gas/app.c	2017-03-24 13:52:02.141327121 +0000
@@ -1187,7 +1187,7 @@ do_scrub_chars (size_t (*get) (char *, s
 		  state = -2;
 		  break;
 		}
-	      else
+	      else if (ch2 != EOF)
 		{
 		  UNGET (ch2);
 		}
diff -rup binutils.orig/ld/ldlex.c binutils-2.27/ld/ldlex.c
--- binutils.orig/ld/ldlex.c	2017-03-24 13:50:55.613184724 +0000
+++ binutils-2.27/ld/ldlex.c	2017-03-24 14:20:47.319068827 +0000
@@ -1,5 +1,5 @@
 
-#line 3 "ldlex.c"
+#line 3 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.c"
 
 #define  YY_INT_ALIGNED short int
 
@@ -7,8 +7,8 @@
 
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 35
+#define YY_FLEX_MINOR_VERSION 6
+#define YY_FLEX_SUBMINOR_VERSION 0
 #if YY_FLEX_SUBMINOR_VERSION > 0
 #define FLEX_BETA
 #endif
@@ -46,7 +46,6 @@ typedef int16_t flex_int16_t;
 typedef uint16_t flex_uint16_t;
 typedef int32_t flex_int32_t;
 typedef uint32_t flex_uint32_t;
-typedef uint64_t flex_uint64_t;
 #else
 typedef signed char flex_int8_t;
 typedef short int flex_int16_t;
@@ -54,7 +53,6 @@ typedef int flex_int32_t;
 typedef unsigned char flex_uint8_t; 
 typedef unsigned short int flex_uint16_t;
 typedef unsigned int flex_uint32_t;
-#endif /* ! C99 */
 
 /* Limits of integral types. */
 #ifndef INT8_MIN
@@ -85,6 +83,8 @@ typedef unsigned int flex_uint32_t;
 #define UINT32_MAX             (4294967295U)
 #endif
 
+#endif /* ! C99 */
+
 #endif /* ! FLEXINT_H */
 
 #ifdef __cplusplus
@@ -141,7 +141,15 @@ typedef unsigned int flex_uint32_t;
 
 /* Size of default input buffer. */
 #ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
 #define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
 #endif
 
 /* The state buf must be large enough to hold one state per character in the main buffer.
@@ -167,13 +175,14 @@ extern FILE *yyin, *yyout;
 #define EOB_ACT_LAST_MATCH 2
 
     #define YY_LESS_LINENO(n)
+    #define YY_LINENO_REWIND_TO(ptr)
     
 /* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
 	do \
 		{ \
 		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
+        yy_size_t yyless_macro_arg = (n); \
         YY_LESS_LINENO(yyless_macro_arg);\
 		*yy_cp = (yy_hold_char); \
 		YY_RESTORE_YY_MORE_OFFSET \
@@ -343,11 +352,17 @@ extern int yylineno;
 int yylineno = 1;
 
 extern char *yytext;
+#ifdef yytext_ptr
+#undef yytext_ptr
+#endif
 #define yytext_ptr yytext
 
 static yy_state_type yy_get_previous_state (void );
 static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
 static int yy_get_next_buffer (void );
+#if defined(__GNUC__) && __GNUC__ >= 3
+__attribute__((__noreturn__))
+#endif
 static void yy_fatal_error (yyconst char msg[]  );
 
 /* Done after the current pattern has been matched and before the
@@ -355,7 +370,7 @@ static void yy_fatal_error (yyconst char
  */
 #define YY_DO_BEFORE_ACTION \
 	(yytext_ptr) = yy_bp; \
-	yyleng = (yy_size_t) (yy_cp - yy_bp); \
+	yyleng = (size_t) (yy_cp - yy_bp); \
 	(yy_hold_char) = *yy_cp; \
 	*yy_cp = '\0'; \
 	(yy_c_buf_p) = yy_cp;
@@ -568,7 +583,7 @@ static yyconst flex_int16_t yy_accept[17
       174,   84,   84,    0
     } ;
 
-static yyconst flex_int32_t yy_ec[256] =
+static yyconst YY_CHAR yy_ec[256] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
         1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
@@ -600,7 +615,7 @@ static yyconst flex_int32_t yy_ec[256] =
         1,    1,    1,    1,    1
     } ;
 
-static yyconst flex_int32_t yy_meta[83] =
+static yyconst YY_CHAR yy_meta[83] =
     {   0,
         1,    1,    2,    3,    1,    1,    4,    1,    1,    1,
         1,    3,    5,    6,    7,    8,    9,   10,   10,   10,
@@ -613,7 +628,7 @@ static yyconst flex_int32_t yy_meta[83]
         1,    9
     } ;
 
-static yyconst flex_int16_t yy_base[1807] =
+static yyconst flex_uint16_t yy_base[1807] =
     {   0,
         0,    0,    0,    0,   82,  163,  244,    0,  326,    0,
       408,  489,  570,    0,  112,  114,  652,  734,  816,  898,
@@ -1019,7 +1034,7 @@ static yyconst flex_int16_t yy_def[1807]
      1774, 1774, 1774, 1774, 1774, 1774
     } ;
 
-static yyconst flex_int16_t yy_nxt[2940] =
+static yyconst flex_uint16_t yy_nxt[2940] =
     {   0,
        23,   24,   25,   26,   27,   23,   28,   29,   30,   31,
        32,   33,   34,   35,   36,   37,   38,   39,   40,   40,
@@ -1687,8 +1702,8 @@ int yy_flex_debug = 0;
 #define YY_MORE_ADJ 0
 #define YY_RESTORE_YY_MORE_OFFSET
 char *yytext;
-#line 1 "ldlex.l"
-#line 4 "ldlex.l"
+#line 1 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
+#line 4 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 
 /* Copyright (C) 1991-2016 Free Software Foundation, Inc.
    Written by Steve Chamberlain of Cygnus Support.
@@ -1788,7 +1803,7 @@ int yywrap (void) { return 1; }
 
 
 
-#line 1792 "ldlex.c"
+#line 1807 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.c"
 
 #define INITIAL 0
 #define SCRIPT 1
@@ -1830,11 +1845,11 @@ void yyset_extra (YY_EXTRA_TYPE user_def
 
 FILE *yyget_in (void );
 
-void yyset_in  (FILE * in_str  );
+void yyset_in  (FILE * _in_str  );
 
 FILE *yyget_out (void );
 
-void yyset_out  (FILE * out_str  );
+void yyset_out  (FILE * _out_str  );
 
 yy_size_t yyget_leng (void );
 
@@ -1842,7 +1857,7 @@ char *yyget_text (void );
 
 int yyget_lineno (void );
 
-void yyset_lineno (int line_number  );
+void yyset_lineno (int _line_number  );
 
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
@@ -1856,6 +1871,10 @@ extern int yywrap (void );
 #endif
 #endif
 
+#ifndef YY_NO_UNPUT
+    
+#endif
+
 #ifndef yytext_ptr
 static void yy_flex_strncpy (char *,yyconst char *,int );
 #endif
@@ -1876,7 +1895,12 @@ static int input (void );
 
 /* Amount of stuff to slurp up with each read. */
 #ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
 #define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
 #endif
 
 /* Copy whatever the last rule matched to the standard output. */
@@ -1884,7 +1908,7 @@ static int input (void );
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO fwrite( yytext, yyleng, 1, yyout )
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -1895,7 +1919,7 @@ static int input (void );
 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
 		{ \
 		int c = '*'; \
-		yy_size_t n; \
+		size_t n; \
 		for ( n = 0; n < max_size && \
 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
 			buf[n] = (char) c; \
@@ -1963,7 +1987,7 @@ extern int yylex (void);
 
 /* Code executed at the end of each rule. */
 #ifndef YY_BREAK
-#define YY_BREAK break;
+#define YY_BREAK /*LINTED*/break;
 #endif
 
 #define YY_RULE_SETUP \
@@ -1973,31 +1997,10 @@ extern int yylex (void);
  */
 YY_DECL
 {
-	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
-	register int yy_act;
+	yy_state_type yy_current_state;
+	char *yy_cp, *yy_bp;
+	int yy_act;
     
-#line 121 "ldlex.l"
-
-
-  if (parser_input != input_selected)
-    {
-      /* The first token of the input determines the initial parser state.  */
-      input_type t = parser_input;
-      parser_input = input_selected;
-      switch (t)
-	{
-	case input_script: return INPUT_SCRIPT; break;
-	case input_mri_script: return INPUT_MRI_SCRIPT; break;
-	case input_version_script: return INPUT_VERSION_SCRIPT; break;
-	case input_dynamic_list: return INPUT_DYNAMIC_LIST; break;
-	case input_defsym: return INPUT_DEFSYM; break;
-	default: abort ();
-	}
-    }
-
-#line 2000 "ldlex.c"
-
 	if ( !(yy_init) )
 		{
 		(yy_init) = 1;
@@ -2024,7 +2027,29 @@ YY_DECL
 		yy_load_buffer_state( );
 		}
 
-	while ( 1 )		/* loops until end-of-file is reached */
+	{
+#line 121 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
+
+
+  if (parser_input != input_selected)
+    {
+      /* The first token of the input determines the initial parser state.  */
+      input_type t = parser_input;
+      parser_input = input_selected;
+      switch (t)
+	{
+	case input_script: return INPUT_SCRIPT; break;
+	case input_mri_script: return INPUT_MRI_SCRIPT; break;
+	case input_version_script: return INPUT_VERSION_SCRIPT; break;
+	case input_dynamic_list: return INPUT_DYNAMIC_LIST; break;
+	case input_defsym: return INPUT_DEFSYM; break;
+	default: abort ();
+	}
+    }
+
+#line 2051 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.c"
+
+	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
 		{
 		yy_cp = (yy_c_buf_p);
 
@@ -2040,7 +2065,7 @@ YY_DECL
 yy_match:
 		do
 			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
 			if ( yy_accept[yy_current_state] )
 				{
 				(yy_last_accepting_state) = yy_current_state;
@@ -2081,32 +2106,32 @@ do_action:	/* This label is used only to
 
 case 1:
 YY_RULE_SETUP
-#line 139 "ldlex.l"
+#line 139 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { comment (); }
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 142 "ldlex.l"
+#line 142 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('-');}
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 143 "ldlex.l"
+#line 143 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('+');}
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 144 "ldlex.l"
+#line 144 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { yylval.name = xstrdup (yytext); return NAME; }
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 145 "ldlex.l"
+#line 145 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('='); }
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 147 "ldlex.l"
+#line 147 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 {
   				yylval.integer = bfd_scan_vma (yytext + 1, 0, 16);
 				yylval.bigint.str = NULL;
@@ -2115,7 +2140,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 153 "ldlex.l"
+#line 153 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 {
 				   int ibase ;
 				   switch (yytext[yyleng - 1]) {
@@ -2144,7 +2169,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 178 "ldlex.l"
+#line 178 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 {
 				  char *s = yytext;
 				  int ibase = 0;
@@ -2177,829 +2202,829 @@ YY_RULE_SETUP
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 207 "ldlex.l"
+#line 207 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(']');}
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 208 "ldlex.l"
+#line 208 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('[');}
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 209 "ldlex.l"
+#line 209 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(LSHIFTEQ);}
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 210 "ldlex.l"
+#line 210 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(RSHIFTEQ);}
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 211 "ldlex.l"
+#line 211 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(OROR);}
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 212 "ldlex.l"
+#line 212 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(EQ);}
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 213 "ldlex.l"
+#line 213 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(NE);}
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 214 "ldlex.l"
+#line 214 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(GE);}
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 215 "ldlex.l"
+#line 215 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(LE);}
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 216 "ldlex.l"
+#line 216 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(LSHIFT);}
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 217 "ldlex.l"
+#line 217 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(RSHIFT);}
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 218 "ldlex.l"
+#line 218 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(PLUSEQ);}
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 219 "ldlex.l"
+#line 219 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(MINUSEQ);}
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 220 "ldlex.l"
+#line 220 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(MULTEQ);}
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 221 "ldlex.l"
+#line 221 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(DIVEQ);}
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 222 "ldlex.l"
+#line 222 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ANDEQ);}
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 223 "ldlex.l"
+#line 223 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(OREQ);}
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 224 "ldlex.l"
+#line 224 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ANDAND);}
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 225 "ldlex.l"
+#line 225 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('>');}
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 226 "ldlex.l"
+#line 226 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(',');}
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 227 "ldlex.l"
+#line 227 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('&');}
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 228 "ldlex.l"
+#line 228 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('|');}
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 229 "ldlex.l"
+#line 229 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('~');}
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 230 "ldlex.l"
+#line 230 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('!');}
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
-#line 231 "ldlex.l"
+#line 231 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('?');}
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 232 "ldlex.l"
+#line 232 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('*');}
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 233 "ldlex.l"
+#line 233 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('+');}
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 234 "ldlex.l"
+#line 234 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('-');}
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 235 "ldlex.l"
+#line 235 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('/');}
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 236 "ldlex.l"
+#line 236 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('%');}
 	YY_BREAK
 case 39:
 YY_RULE_SETUP
-#line 237 "ldlex.l"
+#line 237 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('<');}
 	YY_BREAK
 case 40:
 YY_RULE_SETUP
-#line 238 "ldlex.l"
+#line 238 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('=');}
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
-#line 239 "ldlex.l"
+#line 239 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('}') ; }
 	YY_BREAK
 case 42:
 YY_RULE_SETUP
-#line 240 "ldlex.l"
+#line 240 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('{'); }
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
-#line 241 "ldlex.l"
+#line 241 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(')');}
 	YY_BREAK
 case 44:
 YY_RULE_SETUP
-#line 242 "ldlex.l"
+#line 242 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN('(');}
 	YY_BREAK
 case 45:
 YY_RULE_SETUP
-#line 243 "ldlex.l"
+#line 243 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(':'); }
 	YY_BREAK
 case 46:
 YY_RULE_SETUP
-#line 244 "ldlex.l"
+#line 244 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(';');}
 	YY_BREAK
 case 47:
 YY_RULE_SETUP
-#line 245 "ldlex.l"
+#line 245 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(MEMORY);}
 	YY_BREAK
 case 48:
 YY_RULE_SETUP
-#line 246 "ldlex.l"
+#line 246 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(REGION_ALIAS);}
 	YY_BREAK
 case 49:
 YY_RULE_SETUP
-#line 247 "ldlex.l"
+#line 247 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(LD_FEATURE);}
 	YY_BREAK
 case 50:
 YY_RULE_SETUP
-#line 248 "ldlex.l"
+#line 248 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ORIGIN);}
 	YY_BREAK
 case 51:
 YY_RULE_SETUP
-#line 249 "ldlex.l"
+#line 249 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(VERSIONK);}
 	YY_BREAK
 case 52:
 YY_RULE_SETUP
-#line 250 "ldlex.l"
+#line 250 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(BLOCK);}
 	YY_BREAK
 case 53:
 YY_RULE_SETUP
-#line 251 "ldlex.l"
+#line 251 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(BIND);}
 	YY_BREAK
 case 54:
 YY_RULE_SETUP
-#line 252 "ldlex.l"
+#line 252 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(LENGTH);}
 	YY_BREAK
 case 55:
 YY_RULE_SETUP
-#line 253 "ldlex.l"
+#line 253 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ALIGN_K);}
 	YY_BREAK
 case 56:
 YY_RULE_SETUP
-#line 254 "ldlex.l"
+#line 254 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(DATA_SEGMENT_ALIGN);}
 	YY_BREAK
 case 57:
 YY_RULE_SETUP
-#line 255 "ldlex.l"
+#line 255 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(DATA_SEGMENT_RELRO_END);}
 	YY_BREAK
 case 58:
 YY_RULE_SETUP
-#line 256 "ldlex.l"
+#line 256 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(DATA_SEGMENT_END);}
 	YY_BREAK
 case 59:
 YY_RULE_SETUP
-#line 257 "ldlex.l"
+#line 257 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ADDR);}
 	YY_BREAK
 case 60:
 YY_RULE_SETUP
-#line 258 "ldlex.l"
+#line 258 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(LOADADDR);}
 	YY_BREAK
 case 61:
 YY_RULE_SETUP
-#line 259 "ldlex.l"
+#line 259 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ALIGNOF); }
 	YY_BREAK
 case 62:
 YY_RULE_SETUP
-#line 260 "ldlex.l"
+#line 260 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(MAX_K); }
 	YY_BREAK
 case 63:
 YY_RULE_SETUP
-#line 261 "ldlex.l"
+#line 261 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(MIN_K); }
 	YY_BREAK
 case 64:
 YY_RULE_SETUP
-#line 262 "ldlex.l"
+#line 262 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(LOG2CEIL); }
 	YY_BREAK
 case 65:
 YY_RULE_SETUP
-#line 263 "ldlex.l"
+#line 263 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ASSERT_K); }
 	YY_BREAK
 case 66:
 YY_RULE_SETUP
-#line 264 "ldlex.l"
+#line 264 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ENTRY);}
 	YY_BREAK
 case 67:
 YY_RULE_SETUP
-#line 265 "ldlex.l"
+#line 265 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(EXTERN);}
 	YY_BREAK
 case 68:
 YY_RULE_SETUP
-#line 266 "ldlex.l"
+#line 266 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(NEXT);}
 	YY_BREAK
 case 69:
 YY_RULE_SETUP
-#line 267 "ldlex.l"
+#line 267 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(SIZEOF_HEADERS);}
 	YY_BREAK
 case 70:
 YY_RULE_SETUP
-#line 268 "ldlex.l"
+#line 268 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(SIZEOF_HEADERS);}
 	YY_BREAK
 case 71:
 YY_RULE_SETUP
-#line 269 "ldlex.l"
+#line 269 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(SEGMENT_START);}
 	YY_BREAK
 case 72:
 YY_RULE_SETUP
-#line 270 "ldlex.l"
+#line 270 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(MAP);}
 	YY_BREAK
 case 73:
 YY_RULE_SETUP
-#line 271 "ldlex.l"
+#line 271 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(SIZEOF);}
 	YY_BREAK
 case 74:
 YY_RULE_SETUP
-#line 272 "ldlex.l"
+#line 272 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(TARGET_K);}
 	YY_BREAK
 case 75:
 YY_RULE_SETUP
-#line 273 "ldlex.l"
+#line 273 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(SEARCH_DIR);}
 	YY_BREAK
 case 76:
 YY_RULE_SETUP
-#line 274 "ldlex.l"
+#line 274 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(OUTPUT);}
 	YY_BREAK
 case 77:
 YY_RULE_SETUP
-#line 275 "ldlex.l"
+#line 275 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(INPUT);}
 	YY_BREAK
 case 78:
 YY_RULE_SETUP
-#line 276 "ldlex.l"
+#line 276 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(GROUP);}
 	YY_BREAK
 case 79:
 YY_RULE_SETUP
-#line 277 "ldlex.l"
+#line 277 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(AS_NEEDED);}
 	YY_BREAK
 case 80:
 YY_RULE_SETUP
-#line 278 "ldlex.l"
+#line 278 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(DEFINED);}
 	YY_BREAK
 case 81:
 YY_RULE_SETUP
-#line 279 "ldlex.l"
+#line 279 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(CREATE_OBJECT_SYMBOLS);}
 	YY_BREAK
 case 82:
 YY_RULE_SETUP
-#line 280 "ldlex.l"
+#line 280 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN( CONSTRUCTORS);}
 	YY_BREAK
 case 83:
 YY_RULE_SETUP
-#line 281 "ldlex.l"
+#line 281 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(FORCE_COMMON_ALLOCATION);}
 	YY_BREAK
 case 84:
 YY_RULE_SETUP
-#line 282 "ldlex.l"
+#line 282 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(INHIBIT_COMMON_ALLOCATION);}
 	YY_BREAK
 case 85:
 YY_RULE_SETUP
-#line 283 "ldlex.l"
+#line 283 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(SECTIONS);}
 	YY_BREAK
 case 86:
 YY_RULE_SETUP
-#line 284 "ldlex.l"
+#line 284 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(INSERT_K);}
 	YY_BREAK
 case 87:
 YY_RULE_SETUP
-#line 285 "ldlex.l"
+#line 285 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(AFTER);}
 	YY_BREAK
 case 88:
 YY_RULE_SETUP
-#line 286 "ldlex.l"
+#line 286 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(BEFORE);}
 	YY_BREAK
 case 89:
 YY_RULE_SETUP
-#line 287 "ldlex.l"
+#line 287 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(FILL);}
 	YY_BREAK
 case 90:
 YY_RULE_SETUP
-#line 288 "ldlex.l"
+#line 288 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(STARTUP);}
 	YY_BREAK
 case 91:
 YY_RULE_SETUP
-#line 289 "ldlex.l"
+#line 289 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(OUTPUT_FORMAT);}
 	YY_BREAK
 case 92:
 YY_RULE_SETUP
-#line 290 "ldlex.l"
+#line 290 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN( OUTPUT_ARCH);}
 	YY_BREAK
 case 93:
 YY_RULE_SETUP
-#line 291 "ldlex.l"
+#line 291 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(HLL);}
 	YY_BREAK
 case 94:
 YY_RULE_SETUP
-#line 292 "ldlex.l"
+#line 292 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(SYSLIB);}
 	YY_BREAK
 case 95:
 YY_RULE_SETUP
-#line 293 "ldlex.l"
+#line 293 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(FLOAT);}
 	YY_BREAK
 case 96:
 YY_RULE_SETUP
-#line 294 "ldlex.l"
+#line 294 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN( QUAD);}
 	YY_BREAK
 case 97:
 YY_RULE_SETUP
-#line 295 "ldlex.l"
+#line 295 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN( SQUAD);}
 	YY_BREAK
 case 98:
 YY_RULE_SETUP
-#line 296 "ldlex.l"
+#line 296 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN( LONG);}
 	YY_BREAK
 case 99:
 YY_RULE_SETUP
-#line 297 "ldlex.l"
+#line 297 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN( SHORT);}
 	YY_BREAK
 case 100:
 YY_RULE_SETUP
-#line 298 "ldlex.l"
+#line 298 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN( BYTE);}
 	YY_BREAK
 case 101:
 YY_RULE_SETUP
-#line 299 "ldlex.l"
+#line 299 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(NOFLOAT);}
 	YY_BREAK
 case 102:
 YY_RULE_SETUP
-#line 300 "ldlex.l"
+#line 300 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(NOCROSSREFS);}
 	YY_BREAK
 case 103:
 YY_RULE_SETUP
-#line 301 "ldlex.l"
+#line 301 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(NOCROSSREFS_TO);}
 	YY_BREAK
 case 104:
 YY_RULE_SETUP
-#line 302 "ldlex.l"
+#line 302 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(OVERLAY); }
 	YY_BREAK
 case 105:
 YY_RULE_SETUP
-#line 303 "ldlex.l"
+#line 303 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(SORT_BY_NAME); }
 	YY_BREAK
 case 106:
 YY_RULE_SETUP
-#line 304 "ldlex.l"
+#line 304 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(SORT_BY_ALIGNMENT); }
 	YY_BREAK
 case 107:
 YY_RULE_SETUP
-#line 305 "ldlex.l"
+#line 305 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(SORT_BY_NAME); }
 	YY_BREAK
 case 108:
 YY_RULE_SETUP
-#line 306 "ldlex.l"
+#line 306 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(SORT_BY_INIT_PRIORITY); }
 	YY_BREAK
 case 109:
 YY_RULE_SETUP
-#line 307 "ldlex.l"
+#line 307 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(SORT_NONE); }
 	YY_BREAK
 case 110:
 YY_RULE_SETUP
-#line 308 "ldlex.l"
+#line 308 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(NOLOAD);}
 	YY_BREAK
 case 111:
 YY_RULE_SETUP
-#line 309 "ldlex.l"
+#line 309 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(DSECT);}
 	YY_BREAK
 case 112:
 YY_RULE_SETUP
-#line 310 "ldlex.l"
+#line 310 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(COPY);}
 	YY_BREAK
 case 113:
 YY_RULE_SETUP
-#line 311 "ldlex.l"
+#line 311 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(INFO);}
 	YY_BREAK
 case 114:
 YY_RULE_SETUP
-#line 312 "ldlex.l"
+#line 312 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(OVERLAY);}
 	YY_BREAK
 case 115:
 YY_RULE_SETUP
-#line 313 "ldlex.l"
+#line 313 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ONLY_IF_RO); }
 	YY_BREAK
 case 116:
 YY_RULE_SETUP
-#line 314 "ldlex.l"
+#line 314 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ONLY_IF_RW); }
 	YY_BREAK
 case 117:
 YY_RULE_SETUP
-#line 315 "ldlex.l"
+#line 315 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(SPECIAL); }
 	YY_BREAK
 case 118:
 YY_RULE_SETUP
-#line 316 "ldlex.l"
+#line 316 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ORIGIN);}
 	YY_BREAK
 case 119:
 YY_RULE_SETUP
-#line 317 "ldlex.l"
+#line 317 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ORIGIN);}
 	YY_BREAK
 case 120:
 YY_RULE_SETUP
-#line 318 "ldlex.l"
+#line 318 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN( LENGTH);}
 	YY_BREAK
 case 121:
 YY_RULE_SETUP
-#line 319 "ldlex.l"
+#line 319 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN( LENGTH);}
 	YY_BREAK
 case 122:
 YY_RULE_SETUP
-#line 320 "ldlex.l"
+#line 320 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(INPUT_SECTION_FLAGS); }
 	YY_BREAK
 case 123:
 YY_RULE_SETUP
-#line 321 "ldlex.l"
+#line 321 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(INCLUDE);}
 	YY_BREAK
 case 124:
 YY_RULE_SETUP
-#line 322 "ldlex.l"
+#line 322 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN (PHDRS); }
 	YY_BREAK
 case 125:
 YY_RULE_SETUP
-#line 323 "ldlex.l"
+#line 323 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(AT);}
 	YY_BREAK
 case 126:
 YY_RULE_SETUP
-#line 324 "ldlex.l"
+#line 324 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ALIGN_WITH_INPUT);}
 	YY_BREAK
 case 127:
 YY_RULE_SETUP
-#line 325 "ldlex.l"
+#line 325 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(SUBALIGN);}
 	YY_BREAK
 case 128:
 YY_RULE_SETUP
-#line 326 "ldlex.l"
+#line 326 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(HIDDEN); }
 	YY_BREAK
 case 129:
 YY_RULE_SETUP
-#line 327 "ldlex.l"
+#line 327 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(PROVIDE); }
 	YY_BREAK
 case 130:
 YY_RULE_SETUP
-#line 328 "ldlex.l"
+#line 328 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(PROVIDE_HIDDEN); }
 	YY_BREAK
 case 131:
 YY_RULE_SETUP
-#line 329 "ldlex.l"
+#line 329 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(KEEP); }
 	YY_BREAK
 case 132:
 YY_RULE_SETUP
-#line 330 "ldlex.l"
+#line 330 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(EXCLUDE_FILE); }
 	YY_BREAK
 case 133:
 YY_RULE_SETUP
-#line 331 "ldlex.l"
+#line 331 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(CONSTANT);}
 	YY_BREAK
 case 134:
 /* rule 134 can match eol */
 YY_RULE_SETUP
-#line 332 "ldlex.l"
+#line 332 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { ++ lineno; }
 	YY_BREAK
 case 135:
 /* rule 135 can match eol */
 YY_RULE_SETUP
-#line 333 "ldlex.l"
+#line 333 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { ++ lineno;  RTOKEN(NEWLINE); }
 	YY_BREAK
 case 136:
 YY_RULE_SETUP
-#line 334 "ldlex.l"
+#line 334 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { /* Mri comment line */ }
 	YY_BREAK
 case 137:
 YY_RULE_SETUP
-#line 335 "ldlex.l"
+#line 335 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { /* Mri comment line */ }
 	YY_BREAK
 case 138:
 YY_RULE_SETUP
-#line 336 "ldlex.l"
+#line 336 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ENDWORD); }
 	YY_BREAK
 case 139:
 YY_RULE_SETUP
-#line 337 "ldlex.l"
+#line 337 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ALIGNMOD);}
 	YY_BREAK
 case 140:
 YY_RULE_SETUP
-#line 338 "ldlex.l"
+#line 338 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ALIGN_K);}
 	YY_BREAK
 case 141:
 YY_RULE_SETUP
-#line 339 "ldlex.l"
+#line 339 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(CHIP); }
 	YY_BREAK
 case 142:
 YY_RULE_SETUP
-#line 340 "ldlex.l"
+#line 340 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(BASE); }
 	YY_BREAK
 case 143:
 YY_RULE_SETUP
-#line 341 "ldlex.l"
+#line 341 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ALIAS); }
 	YY_BREAK
 case 144:
 YY_RULE_SETUP
-#line 342 "ldlex.l"
+#line 342 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(TRUNCATE); }
 	YY_BREAK
 case 145:
 YY_RULE_SETUP
-#line 343 "ldlex.l"
+#line 343 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(LOAD); }
 	YY_BREAK
 case 146:
 YY_RULE_SETUP
-#line 344 "ldlex.l"
+#line 344 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(PUBLIC); }
 	YY_BREAK
 case 147:
 YY_RULE_SETUP
-#line 345 "ldlex.l"
+#line 345 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ORDER); }
 	YY_BREAK
 case 148:
 YY_RULE_SETUP
-#line 346 "ldlex.l"
+#line 346 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(NAMEWORD); }
 	YY_BREAK
 case 149:
 YY_RULE_SETUP
-#line 347 "ldlex.l"
+#line 347 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(FORMAT); }
 	YY_BREAK
 case 150:
 YY_RULE_SETUP
-#line 348 "ldlex.l"
+#line 348 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(CASE); }
 	YY_BREAK
 case 151:
 YY_RULE_SETUP
-#line 349 "ldlex.l"
+#line 349 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(START); }
 	YY_BREAK
 case 152:
 YY_RULE_SETUP
-#line 350 "ldlex.l"
+#line 350 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(LIST); /* LIST and ignore to end of line */ }
 	YY_BREAK
 case 153:
 YY_RULE_SETUP
-#line 351 "ldlex.l"
+#line 351 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(SECT); }
 	YY_BREAK
 case 154:
 YY_RULE_SETUP
-#line 352 "ldlex.l"
+#line 352 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ABSOLUTE); }
 	YY_BREAK
 case 155:
 YY_RULE_SETUP
-#line 353 "ldlex.l"
+#line 353 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ENDWORD); }
 	YY_BREAK
 case 156:
 YY_RULE_SETUP
-#line 354 "ldlex.l"
+#line 354 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ALIGNMOD);}
 	YY_BREAK
 case 157:
 YY_RULE_SETUP
-#line 355 "ldlex.l"
+#line 355 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ALIGN_K);}
 	YY_BREAK
 case 158:
 YY_RULE_SETUP
-#line 356 "ldlex.l"
+#line 356 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(CHIP); }
 	YY_BREAK
 case 159:
 YY_RULE_SETUP
-#line 357 "ldlex.l"
+#line 357 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(BASE); }
 	YY_BREAK
 case 160:
 YY_RULE_SETUP
-#line 358 "ldlex.l"
+#line 358 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ALIAS); }
 	YY_BREAK
 case 161:
 YY_RULE_SETUP
-#line 359 "ldlex.l"
+#line 359 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(TRUNCATE); }
 	YY_BREAK
 case 162:
 YY_RULE_SETUP
-#line 360 "ldlex.l"
+#line 360 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(LOAD); }
 	YY_BREAK
 case 163:
 YY_RULE_SETUP
-#line 361 "ldlex.l"
+#line 361 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(PUBLIC); }
 	YY_BREAK
 case 164:
 YY_RULE_SETUP
-#line 362 "ldlex.l"
+#line 362 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ORDER); }
 	YY_BREAK
 case 165:
 YY_RULE_SETUP
-#line 363 "ldlex.l"
+#line 363 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(NAMEWORD); }
 	YY_BREAK
 case 166:
 YY_RULE_SETUP
-#line 364 "ldlex.l"
+#line 364 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(FORMAT); }
 	YY_BREAK
 case 167:
 YY_RULE_SETUP
-#line 365 "ldlex.l"
+#line 365 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(CASE); }
 	YY_BREAK
 case 168:
 YY_RULE_SETUP
-#line 366 "ldlex.l"
+#line 366 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(EXTERN); }
 	YY_BREAK
 case 169:
 YY_RULE_SETUP
-#line 367 "ldlex.l"
+#line 367 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(START); }
 	YY_BREAK
 case 170:
 YY_RULE_SETUP
-#line 368 "ldlex.l"
+#line 368 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(LIST); /* LIST and ignore to end of line */ }
 	YY_BREAK
 case 171:
 YY_RULE_SETUP
-#line 369 "ldlex.l"
+#line 369 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(SECT); }
 	YY_BREAK
 case 172:
 YY_RULE_SETUP
-#line 370 "ldlex.l"
+#line 370 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(ABSOLUTE); }
 	YY_BREAK
 case 173:
 YY_RULE_SETUP
-#line 372 "ldlex.l"
+#line 372 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 {
 /* Filename without commas, needed to parse mri stuff */
 				 yylval.name = xstrdup (yytext);
@@ -3008,7 +3033,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 174:
 YY_RULE_SETUP
-#line 379 "ldlex.l"
+#line 379 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 {
 				 yylval.name = xstrdup (yytext);
 				  return NAME;
@@ -3016,7 +3041,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 175:
 YY_RULE_SETUP
-#line 383 "ldlex.l"
+#line 383 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 {
 /* Filename to be prefixed by --sysroot or when non-sysrooted, nothing.  */
 				 yylval.name = xstrdup (yytext);
@@ -3025,7 +3050,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 176:
 YY_RULE_SETUP
-#line 388 "ldlex.l"
+#line 388 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 {
 				  yylval.name = xstrdup (yytext + 2);
 				  return LNAME;
@@ -3033,7 +3058,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 177:
 YY_RULE_SETUP
-#line 392 "ldlex.l"
+#line 392 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 {
 				 yylval.name = xstrdup (yytext);
 				  return NAME;
@@ -3041,7 +3066,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 178:
 YY_RULE_SETUP
-#line 396 "ldlex.l"
+#line 396 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 {
 				  yylval.name = xstrdup (yytext + 2);
 				  return LNAME;
@@ -3049,7 +3074,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 179:
 YY_RULE_SETUP
-#line 400 "ldlex.l"
+#line 400 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 {
 		/* Annoyingly, this pattern can match comments, and we have
 		   longest match issues to consider.  So if the first two
@@ -3070,66 +3095,72 @@ YY_RULE_SETUP
 case 180:
 /* rule 180 can match eol */
 YY_RULE_SETUP
-#line 417 "ldlex.l"
+#line 417 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 {
 					/* No matter the state, quotes
-					   give what's inside */
+                                           give what's inside.  */
+					bfd_size_type len;
 					yylval.name = xstrdup (yytext + 1);
-					yylval.name[yyleng - 2] = 0;
+					/* PR ld/20906.  A corrupt input file
+                                        can contain bogus strings.  */
+					len = strlen (yylval.name);
+					if (len > yyleng - 2)
+					  len = yyleng - 2;
+					yylval.name[len] = 0;
 					return NAME;
 				}
 	YY_BREAK
 case 181:
 /* rule 181 can match eol */
 YY_RULE_SETUP
-#line 424 "ldlex.l"
+#line 430 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { lineno++;}
 	YY_BREAK
 case 182:
 YY_RULE_SETUP
-#line 425 "ldlex.l"
+#line 431 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { }
 	YY_BREAK
 case 183:
 YY_RULE_SETUP
-#line 427 "ldlex.l"
+#line 433 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { return *yytext; }
 	YY_BREAK
 case 184:
 YY_RULE_SETUP
-#line 429 "ldlex.l"
+#line 435 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(GLOBAL); }
 	YY_BREAK
 case 185:
 YY_RULE_SETUP
-#line 431 "ldlex.l"
+#line 437 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(LOCAL); }
 	YY_BREAK
 case 186:
 YY_RULE_SETUP
-#line 433 "ldlex.l"
+#line 439 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { RTOKEN(EXTERN); }
 	YY_BREAK
 case 187:
 YY_RULE_SETUP
-#line 435 "ldlex.l"
+#line 441 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { yylval.name = xstrdup (yytext);
 				  return VERS_IDENTIFIER; }
 	YY_BREAK
 case 188:
 YY_RULE_SETUP
-#line 438 "ldlex.l"
+#line 444 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { yylval.name = xstrdup (yytext);
 				  return VERS_TAG; }
 	YY_BREAK
 case 189:
 YY_RULE_SETUP
-#line 441 "ldlex.l"
+#line 447 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { BEGIN(VERS_SCRIPT); return *yytext; }
 	YY_BREAK
 case 190:
 YY_RULE_SETUP
-#line 443 "ldlex.l"
+#line 449 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { BEGIN(VERS_NODE);
 				  vers_node_nesting = 0;
 				  return *yytext;
@@ -3137,17 +3168,17 @@ YY_RULE_SETUP
 	YY_BREAK
 case 191:
 YY_RULE_SETUP
-#line 447 "ldlex.l"
+#line 453 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { return *yytext; }
 	YY_BREAK
 case 192:
 YY_RULE_SETUP
-#line 448 "ldlex.l"
+#line 454 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { vers_node_nesting++; return *yytext; }
 	YY_BREAK
 case 193:
 YY_RULE_SETUP
-#line 449 "ldlex.l"
+#line 455 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { if (--vers_node_nesting < 0)
 				    BEGIN(VERS_SCRIPT);
 				  return *yytext;
@@ -3156,17 +3187,17 @@ YY_RULE_SETUP
 case 194:
 /* rule 194 can match eol */
 YY_RULE_SETUP
-#line 454 "ldlex.l"
+#line 460 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { lineno++; }
 	YY_BREAK
 case 195:
 YY_RULE_SETUP
-#line 456 "ldlex.l"
+#line 462 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { /* Eat up comments */ }
 	YY_BREAK
 case 196:
 YY_RULE_SETUP
-#line 458 "ldlex.l"
+#line 464 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 { /* Eat up whitespace */ }
 	YY_BREAK
 case YY_STATE_EOF(INITIAL):
@@ -3179,7 +3210,7 @@ case YY_STATE_EOF(MRI):
 case YY_STATE_EOF(VERS_START):
 case YY_STATE_EOF(VERS_SCRIPT):
 case YY_STATE_EOF(VERS_NODE):
-#line 460 "ldlex.l"
+#line 466 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 {
   include_stack_ptr--;
   if (include_stack_ptr == 0)
@@ -3195,20 +3226,20 @@ case YY_STATE_EOF(VERS_NODE):
 	YY_BREAK
 case 197:
 YY_RULE_SETUP
-#line 473 "ldlex.l"
+#line 479 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 lex_warn_invalid (" in script", yytext);
 	YY_BREAK
 case 198:
 YY_RULE_SETUP
-#line 474 "ldlex.l"
+#line 480 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 lex_warn_invalid (" in expression", yytext);
 	YY_BREAK
 case 199:
 YY_RULE_SETUP
-#line 476 "ldlex.l"
+#line 482 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 ECHO;
 	YY_BREAK
-#line 3212 "ldlex.c"
+#line 3243 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -3337,6 +3368,7 @@ ECHO;
 			"fatal flex scanner internal error--no action found" );
 	} /* end of action switch */
 		} /* end of scanning one token */
+	} /* end of user's declarations */
 } /* end of yylex */
 
 /* yy_get_next_buffer - try to read in a new buffer
@@ -3348,9 +3380,9 @@ ECHO;
  */
 static int yy_get_next_buffer (void)
 {
-    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
-	register char *source = (yytext_ptr);
-	register int number_to_move, i;
+    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	char *source = (yytext_ptr);
+	yy_size_t number_to_move, i;
 	int ret_val;
 
 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
@@ -3379,7 +3411,7 @@ static int yy_get_next_buffer (void)
 	/* Try to read more data. */
 
 	/* First move last chars to start of buffer. */
-	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+	number_to_move = (yy_size_t) ((yy_c_buf_p) - (yytext_ptr)) - 1;
 
 	for ( i = 0; i < number_to_move; ++i )
 		*(dest++) = *(source++);
@@ -3392,14 +3424,14 @@ static int yy_get_next_buffer (void)
 
 	else
 		{
-			yy_size_t num_to_read =
+			int num_to_read =
 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
 
 		while ( num_to_read <= 0 )
 			{ /* Not enough room in the buffer - grow it. */
 
 			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
 
 			int yy_c_buf_p_offset =
 				(int) ((yy_c_buf_p) - b->yy_ch_buf);
@@ -3482,14 +3514,14 @@ static int yy_get_next_buffer (void)
 
     static yy_state_type yy_get_previous_state (void)
 {
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
+	yy_state_type yy_current_state;
+	char *yy_cp;
     
 	yy_current_state = (yy_start);
 
 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
 		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
 		if ( yy_accept[yy_current_state] )
 			{
 			(yy_last_accepting_state) = yy_current_state;
@@ -3514,10 +3546,10 @@ static int yy_get_next_buffer (void)
  */
     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
 {
-	register int yy_is_jam;
-    	register char *yy_cp = (yy_c_buf_p);
+	int yy_is_jam;
+    	char *yy_cp = (yy_c_buf_p);
 
-	register YY_CHAR yy_c = 1;
+	YY_CHAR yy_c = 1;
 	if ( yy_accept[yy_current_state] )
 		{
 		(yy_last_accepting_state) = yy_current_state;
@@ -3532,9 +3564,13 @@ static int yy_get_next_buffer (void)
 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 	yy_is_jam = (yy_current_state == 1774);
 
-	return yy_is_jam ? 0 : yy_current_state;
+		return yy_is_jam ? 0 : yy_current_state;
 }
 
+#ifndef YY_NO_UNPUT
+
+#endif
+
 #ifndef YY_NO_INPUT
 #ifdef __cplusplus
     static int yyinput (void)
@@ -3583,7 +3619,7 @@ static int yy_get_next_buffer (void)
 				case EOB_ACT_END_OF_FILE:
 					{
 					if ( yywrap( ) )
-						return 0;
+						return EOF;
 
 					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
@@ -3684,7 +3720,7 @@ static void yy_load_buffer_state  (void)
 	if ( ! b )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
 
-	b->yy_buf_size = size;
+	b->yy_buf_size = (yy_size_t)size;
 
 	/* yy_ch_buf has to be 2 characters longer than the size given because
 	 * we need to put in 2 end-of-buffer characters.
@@ -3719,10 +3755,6 @@ static void yy_load_buffer_state  (void)
 	yyfree((void *) b  );
 }
 
-#ifndef __cplusplus
-extern int isatty (int );
-#endif /* __cplusplus */
-    
 /* Initializes or reinitializes a buffer.
  * This function is sometimes called more than once on the same buffer,
  * such as during a yyrestart() or at EOF.
@@ -3843,7 +3875,7 @@ static void yyensure_buffer_stack (void)
 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
 		 * immediate realloc on the next call.
          */
-		num_to_alloc = 1;
+      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
 								(num_to_alloc * sizeof(struct yy_buffer_state*)
 								);
@@ -3860,7 +3892,7 @@ static void yyensure_buffer_stack (void)
 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
 
 		/* Increase the buffer to prepare for a possible push. */
-		int grow_size = 8 /* arbitrary grow size */;
+		yy_size_t grow_size = 8 /* arbitrary grow size */;
 
 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
@@ -3927,8 +3959,8 @@ YY_BUFFER_STATE yy_scan_string (yyconst
 
 /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
  * scan from a @e copy of @a bytes.
- * @param bytes the byte buffer to scan
- * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
  * 
  * @return the newly allocated buffer state object.
  */
@@ -3936,7 +3968,8 @@ YY_BUFFER_STATE yy_scan_bytes  (yyconst
 {
 	YY_BUFFER_STATE b;
 	char *buf;
-	yy_size_t n, i;
+	yy_size_t n;
+	yy_size_t i;
     
 	/* Get memory for full buffer, including space for trailing EOB's. */
 	n = _yybytes_len + 2;
@@ -3967,7 +4000,7 @@ YY_BUFFER_STATE yy_scan_bytes  (yyconst
 
 static void yy_fatal_error (yyconst char* msg )
 {
-    	(void) fprintf( stderr, "%s\n", msg );
+			(void) fprintf( stderr, "%s\n", msg );
 	exit( YY_EXIT_FAILURE );
 }
 
@@ -3978,7 +4011,7 @@ static void yy_fatal_error (yyconst char
 	do \
 		{ \
 		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
+        yy_size_t yyless_macro_arg = (n); \
         YY_LESS_LINENO(yyless_macro_arg);\
 		yytext[yyleng] = (yy_hold_char); \
 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
@@ -4033,29 +4066,29 @@ char *yyget_text  (void)
 }
 
 /** Set the current line number.
- * @param line_number
+ * @param _line_number line number
  * 
  */
-void yyset_lineno (int  line_number )
+void yyset_lineno (int  _line_number )
 {
     
-    yylineno = line_number;
+    yylineno = _line_number;
 }
 
 /** Set the input stream. This does not discard the current
  * input buffer.
- * @param in_str A readable stream.
+ * @param _in_str A readable stream.
  * 
  * @see yy_switch_to_buffer
  */
-void yyset_in (FILE *  in_str )
+void yyset_in (FILE *  _in_str )
 {
-        yyin = in_str ;
+        yyin = _in_str ;
 }
 
-void yyset_out (FILE *  out_str )
+void yyset_out (FILE *  _out_str )
 {
-        yyout = out_str ;
+        yyout = _out_str ;
 }
 
 int yyget_debug  (void)
@@ -4063,9 +4096,9 @@ int yyget_debug  (void)
         return yy_flex_debug;
 }
 
-void yyset_debug (int  bdebug )
+void yyset_debug (int  _bdebug )
 {
-        yy_flex_debug = bdebug ;
+        yy_flex_debug = _bdebug ;
 }
 
 static int yy_init_globals (void)
@@ -4125,7 +4158,8 @@ int yylex_destroy  (void)
 #ifndef yytext_ptr
 static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
 {
-	register int i;
+		
+	int i;
 	for ( i = 0; i < n; ++i )
 		s1[i] = s2[i];
 }
@@ -4134,7 +4168,7 @@ static void yy_flex_strncpy (char* s1, y
 #ifdef YY_NEED_STRLEN
 static int yy_flex_strlen (yyconst char * s )
 {
-	register int n;
+	int n;
 	for ( n = 0; s[n]; ++n )
 		;
 
@@ -4144,11 +4178,12 @@ static int yy_flex_strlen (yyconst char
 
 void *yyalloc (yy_size_t  size )
 {
-	return (void *) malloc( size );
+			return (void *) malloc( size );
 }
 
 void *yyrealloc  (void * ptr, yy_size_t  size )
 {
+		
 	/* The cast to (char *) in the following accommodates both
 	 * implementations that use char* generic pointers, and those
 	 * that use void* generic pointers.  It works with the latter
@@ -4161,12 +4196,12 @@ void *yyrealloc  (void * ptr, yy_size_t
 
 void yyfree (void * ptr )
 {
-	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
 }
 
 #define YYTABLES_NAME "yytables"
 
-#line 476 "ldlex.l"
+#line 482 "/work/sources/rhel/binutils/rhel-7.4/binutils-2.27/ld/ldlex.l"
 
 
 
diff -rup binutils.orig/ld/ldlex.l binutils-2.27/ld/ldlex.l
--- binutils.orig/ld/ldlex.l	2017-03-24 13:50:55.613184724 +0000
+++ binutils-2.27/ld/ldlex.l	2017-03-24 14:20:35.039227142 +0000
@@ -416,9 +416,15 @@ V_IDENTIFIER [*?.$_a-zA-Z\[\]\-\!\^\\]([
 
 <EXPRESSION,BOTH,SCRIPT,VERS_NODE,INPUTLIST>"\""[^\"]*"\"" {
 					/* No matter the state, quotes
-					   give what's inside */
+                                           give what's inside.  */
+					bfd_size_type len;
 					yylval.name = xstrdup (yytext + 1);
-					yylval.name[yyleng - 2] = 0;
+					/* PR ld/20906.  A corrupt input file
+                                        can contain bogus strings.  */
+					len = strlen (yylval.name);
+					if (len > yyleng - 2)
+					  len = yyleng - 2;
+					yylval.name[len] = 0;
 					return NAME;
 				}
 <BOTH,SCRIPT,EXPRESSION>"\n"		{ lineno++;}
